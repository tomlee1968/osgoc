#!/usr/bin/perl -w

use strict;

# vmtool -- handle many common VM tasks for GOC VMs
# Tom Lee <thomlee@iu.edu>
# Begun 2009/04/17
# v2.7: 2012/11/09

###############################################################################
# Supported Commands
###############################################################################
# This is meant to be called from one of various symlinks:
#
# lsvm: List all VMs on system
# mkvm <vm_name>: Create a new VM
# rmvm <vm_name>: Delete a VM (the VM cannot be running)
# mvvm <vm_name> <vm_newname>: Rename a VM (the VM cannot be running)
# allvm <vmware-cmd command>: Do a command for all VMs
# rebuild_vmware: Rebuilds VMware Server's modules
#
# where VM names can only contain letters, numbers, and the characters ._+-

###############################################################################
# About the config file
###############################################################################
# The /opt/etc/vmtool.conf file sets the following:
#
# VM_DIR: The full path to the directory containing all VM volumes' mount
# points/directories (usually /vm)
#
# VM_VG: The volume group containing all VM LVs (or containing the /vm LV)
#
# VM_TAG: The LVM tag to give all VM LVs (if they have separate LVs)
#
# USR_LOCAL_SIZE: The default size for /usr/local on VMs; this is given as a
# number and a unit (e.g. "32GiB").  See below for more about units.
#
# VM_SOURCE: The path to the source VM, which will be used as a starting point
# when a new VM is created

###############################################################################
# GOC standards for VMs:
###############################################################################
# Old-style VMware:
#
# 1. There must be a LV on VG $VM_VG (see /opt/etc/vmtool.conf) named <vm_name>
# with tag "vm" (use "--addtag vm" when doing lvcreate)
#
# 2. The filesystem label on that LV's filesystem must be $VM_DIR/<vm_name>
# (use "-L <label>" when doing mkfs)
#
# 3. There must be a mount point at $VM_DIR/<vm_name> for the volume
#
# 4. There must be a line in /etc/fstab to mount that mounts the volume by
# label (LABEL=$VM_DIR/<vm_name> $VM_DIR/<vm_name> default 0 0)
#
# 5. There must be a $VM_DIR/<vm_name>/<vm_name>.vmx
#
# 6. The .vmx file must contain a line: displayname = "<vm_name>"
#
# Upon further reflection, I don't really know why we started using a separate
# LV for each VM.  There was no real reason not to simply have an LV for all
# VMs, giving each VM a directory within that LV.  I moved to that strategy,
# eliminating steps 1-4 above, making things MUCH simpler.
#
# New-style ("flat") VMware:
#
# 1. There must be a mounted volume on $VM_DIR (usually /vm)
#
# 2. There must be a $VM_DIR/<vm_name>/<vm_name>.vmx
#
# 3. The .vmx file must contain a line: displayname = "<vm_name>"
#
# KVM:
#
# 1. There must be a $VM_DIR (usually /var/lib/libvirt/images)
#
# 2. The VM must be consistent with virsh
#
###############################################################################
# Units
###############################################################################
# I've tried to deal with disk and memory sizes consistently within this
# script, with every input being translated to the internal representation, and
# with this internal representation translated to what an external program
# expects.  So here I'm going to document that internal representation.  Within
# this script we deal with a "data amount" (a DA, which usually refers to a
# disk size, a file size or the amount of RAM available to a VM), denoted as
#
# DA = <integer><unit>
#
# with no space between.
#
# <integer>: There has so far been no need to use fractional numbers; integers
# seem to suffice for this script's purposes.
#
# <unit>: This script uses all-lowercase IEEE1541 units -- in other words, I'm
# almost adhering to the IEEE1541 standard, but not quite.  Everything but the
# case.  The units available are as follows:
#
# kb (kilobyte)  =                     1,000 bytes = 10^3 bytes
# mb (megabyte)  =                 1,000,000 bytes = 10^6 bytes  = 1000 kb
# gb (gigabyte)  =             1,000,000,000 bytes = 10^9 bytes  = 1000 mb
# tb (terabyte)  =         1,000,000,000,000 bytes = 10^12 bytes = 1000 gb
# pb (petabyte)  =     1,000,000,000,000,000 bytes = 10^15 bytes = 1000 tb
# eb (exabyte)   = 1,000,000,000,000,000,000 bytes = 10^18 bytes = 1000 pb
# kib (kibibyte) =                     1,024 bytes = 2^10 bytes
# mib (mebibyte) =                 1,048,576 bytes = 2^20 bytes = 1024 kib
# gib (gibibyte) =             1,073,741,824 bytes = 2^30 bytes = 1024 mib
# tib (tebibyte) =         1,099,511,627,776 bytes = 2^40 bytes = 1024 gib
# pib (pebibyte) =     1,125,899,906,842,624 bytes = 2^50 bytes = 1024 tib
# eib (exbibyte) = 1,152,921,504,606,846,976 bytes = 2^60 bytes = 1024 pib
#
# When dealing with hard drive sizes, manufacturers usually measure in
# powers-of-10 units -- they will say "500 GB," by which they mean what we're
# calling "500gb" in this script.  In other words, 500 x 10^9 bytes.  However,
# when dealing with amounts of memory and sizes of files, manufacturers and
# programmers tend to measure in powers-of-2 units -- if they say "32 GB" or
# "32 gigabytes," what they really mean is "32 gibibytes," which we'd call
# "32gib" in this script -- in other terms, 32 x 2^30 bytes.
#
# Again, these are the *internal* units I'm using.  Users can specify the unit
# they're using in various ways:
#
# "LVM units": LVM uses single-letter units and differentiates between
# powers-of-10 and powers-of-2 units by capitalizing.  For example, "1k" means
# 1000 bytes to LVM, while "1K" means 1024 bytes.  Because there's no
# ambiguity, users can specify units in this style to this script, and it will
# just translate.
#
# IEEE1541 units: 1 KB means 1000 bytes, and 1 KiB means 1024 bytes.  The
# international standard.  Users can specify these as well, and this script
# will figure it out.
#
# "Internal units": The ones listed above -- which are actually just IEEE1541
# units in all lowercase.  If users give quantities in these units, which is
# really this script's native language for them, it will work fine.
#
# I'm probably overthinking this, but it will mean no inconsistencies in units.

###############################################################################
# Modules
###############################################################################

use File::Basename;
use File::Temp;
use Getopt::Std;
use IO::Dir qw(DIR_UNLINK);
use IO::File;
use Net::DNS;
use Net::hostent;
use OSSP::uuid;
use POSIX();
use XML::Twig;

###############################################################################
# Settings
###############################################################################

# Version number
$main::VERSION = '2.7';

# Set the path
$ENV{PATH} = join(':', qw(/sbin /bin /usr/sbin /usr/bin /opt/sbin /opt/bin));

# This is the approximate size of all the files in the VM other than the
# /usr/local virtual disk.  If there's a significant change to the VM, change
# this.  This should be in 'gib'.
$CFG::BASE_VM_SIZE = '13gib';

# Config file -- all config variables are in namespace $CFG::
$CFG::CONFIG = '/opt/etc/vmtool.config';

# How the script was called
$CFG::CALLED_AS = basename($0);

# Is this a VMWare Server or qemu/kvm system?
if(-e '/usr/libexec/qemu-kvm') {
  $CFG::KVM = 1;
  $CFG::VM_DIR = '/var/lib/libvirt/images';
} else {
  $CFG::KVM = '';
  $CFG::VM_DIR = '/vm';
}

# Name of stemcell
$CFG::STEMCELL = 'stemcell';

# Where to find (for mkvm) and put (for rebuild_stemcell) the stemcell tarball
$CFG::ARCHIVE_DIR = '/net/cobbler/usr/local/cobbler/pub';

# Whether mkvm should start the VM or not after creating it
$CFG::START = '';

# How many backup stemcells to keep
$CFG::NBAK = 3;

# Default RHEL version (for selecting stemcell image)
$CFG::RHEL_V = '5';

# Default architecture ('x86' or 'x86_64')
$CFG::ARCH = 'x86_64';

# Volume group containing all VM LVs (if using old non-flat LVM)
$CFG::VM_VG = 'vg0';

# LVM tag to give all VM LVs (if using old non-flat LVM)
$CFG::VM_TAG = 'vm';

###############################################################################
# Subroutines
###############################################################################

sub test_cmd() {
  # If $CFG::TEST_MODE is true, prints the given shell command line.
  # Otherwise, executes it.  Returns the command's return code.  In test mode,
  # always returns 0.

  # A command long enough to be broken up into multiple lines for readability
  # can be sent as an array of strings, which this function will join together,
  # or with carriage returns, which this function will replace with spaces.

  my(@cmd) = @_;
  my $cmd = join(' ', @cmd);
  $cmd =~ s/\n/ /gm;
  if($CFG::TEST_MODE) {
    printf("(test mode) %s\n", $cmd);
    return(0);
  }
  return(system($cmd) >> 8);
}

sub read_config() {
  # Read the config file $CFG::CONFIG, if it exists.  Returns '' on success and
  # an error string if there was a problem.

  return("$CFG::CONFIG does not exist") unless (-e $CFG::CONFIG);
  return("Unable to read $CFG::CONFIG: Insufficient permission") unless (-r $CFG::CONFIG);
  our $err = '';
  {
    package CFG;
    my $return = do($CFG::CONFIG);
    if($@) {
      $::err = "Unable to compile $CFG::CONFIG: $@";
    } elsif(!defined($return)) {
      $::err = "Unable to read $CFG::CONFIG: $!";
    } elsif(!$return) {
      $::err = "Unable to process $CFG::CONFIG";
    }
  }
  return($err);
}

sub init() {
  # Do initialization stuff.

  $CFG::VM_HOST_TYPE = &vm_host_type();
  &read_config();
  &get_options();
  if(($ENV{USER} eq 'root') && (!$CFG::KVM)) {
    &fix_vmware_perl_api_errors();
  }
  # For both rebuild_stemcell and mkvm (currently only RHEL5 and x86_64
  # stemcells are supported, but we might be adding RHEL6 stemcells in the
  # future, so there could be a command-line option that selects $CFG::RHEL_V)
  $CFG::STEMCELL_TARBALL = sprintf('%s-%s-%s-%s.tgz',
				   $CFG::STEMCELL,
				   $CFG::ARCH,
				   $CFG::RHEL_V,
				   ($CFG::KVM)?'kvm':'vmw');
  printf("DEBUG: I've been called as %s\n", $CFG::CALLED_AS) if($CFG::DEBUG_MODE);
}

sub main::HELP_MESSAGE() {
  # Print a help message, based on the command in $CFG::CALLED_AS.
  my $std = <<"EOF";
  -d: Debug mode: prints extra debugging output
  -h: Print this help message
  -t: Test mode: prints shell commands instead of executing
  -v: Print the version
EOF
  ;
  if(($CFG::CALLED_AS eq 'mkvm')
     || ($CFG::CALLED_AS eq 'mkvm_classic')) {
    print <<"EOF";
Usage: ${CFG::CALLED_AS} [<options>] <name of new VM>
Options:
$std
  -c: Set the number of virtual CPUs (1 or 2, default=$CFG::NUMVCPUS)
  -e: Set up the new VM's networking on boot, if possible (default=don't)
  -i: Autorun the install script on boot, if possible (default = don't)
  -m: Memory size of new VM (default=$CFG::MEM_SIZE)
  -n: Set the new VM to NOT power on when host boots (default=autostart)
  -p: Start up the new VM after creating (default=don't)
  -r: Choose RHEL version to install (default=$CFG::RHEL_V)
  -s <size>: Size of /usr/local on new VM (default=$CFG::USR_LOCAL_SIZE)
  Size specification: <number>[<unit>]
  Units: k = kb = KB = 1000    K = kib = KiB = 1024
         m = mb = MB = 1e6     M = mib = MiB = 1024^2
         g = gb = GB = 1e9     G = gib = GiB = 1024^3
         t = tb = TB = 1e12    T = tib = TiB = 1024^4
         etc. (default = MiB)
EOF
;
  } elsif($CFG::CALLED_AS eq 'mvvm') {
    print <<"EOF"
Usage: mvvm <VM's old name> <VM's new name>
Options:
$std
EOF
      ;
  } elsif($CFG::CALLED_AS eq 'rmvm') {
    print <<"EOF"
Usage: rmvm <name of VM to delete>
Options:
$std
EOF
      ;
  } elsif($CFG::CALLED_AS eq 'lsvm') {
    print <<"EOF"
Usage: lsvm [<options>]
Options:
$std
  -c: Print output in HTML format with CSS styles (for vmlist)
EOF
      ;
  } elsif($CFG::CALLED_AS eq 'allvm') {
    if($CFG::KVM) {
      print("Usage: allvm <domain command from virsh>\n");
      system("virsh help domain");
    } else {
      print("Usage: allvm <command from vmware-cmd>\n");
      system("vmware-cmd --list");
    }
  } elsif($CFG::CALLED_AS eq 'rebuild_stemcell') {
    print <<"EOF";
Usage: rebuild_stemcell [<options>]
Options:
$std
  -c: Set the number of virtual CPUs (1 or 2, default=$CFG::NUMVCPUS)
  -m: Memory size of new VM (default=$CFG::MEM_SIZE)
  -n: Set the new VM to NOT power on when host boots (default=autostart)
  -r <version>: Choose RHEL version to rebuild (default=$CFG::RHEL_V)
  -s <size>: Size of /usr/local on new VM (default=$CFG::USR_LOCAL_SIZE)
  Size specification: <number>[<unit>]
  Units: k = kb = KB = 1000    K = kib = KiB = 1024
         m = mb = MB = 1e6     M = mib = MiB = 1024^2
         g = gb = GB = 1e9     G = gib = GiB = 1024^3
         t = tb = TB = 1e12    T = tib = TiB = 1024^4
         etc. (default = MiB)
EOF
    ;
  } elsif(($CFG::CALLED_AS eq 'vmup')
	  || ($CFG::CALLED_AS eq 'vmdown')) {
    print <<"EOF"
Usage: $CFG::CALLED_AS <name of VM>
Options:
$std
EOF
      ;
  }
}

sub main::VERSION_MESSAGE() {
  # Print the version.

  print <<"EOF";
$CFG::CALLED_AS version $main::VERSION
EOF
  ;
}

sub get_options() {
  # Deal with command-line options.

  $Getopt::Std::STANDARD_HELP_VERSION = 1;
  %CFG::OPTS = ();
  if(($CFG::CALLED_AS eq 'mkvm')
     || ($CFG::CALLED_AS eq 'mkvm_classic')) {
    &getopts('ac:dehim:npr:s:tv', \%CFG::OPTS);
    if($CFG::OPTS{c}) {
      unless($CFG::KVM) {
	if(($CFG::OPTS{c} != 1) && ($CFG::OPTS{c} != 2)) {
	  die("Valid values for the -c option are 1 and 2.\n");
	}
      }
      $CFG::NUMVCPUS = $CFG::OPTS{c};
    }
    if($CFG::OPTS{e}) {
      $CFG::AUTONET = 1;
    }
    if($CFG::OPTS{i}) {
      $CFG::AUTOINSTALL = 1;
    }
    if($CFG::OPTS{m}) {
      $CFG::MEM_SIZE = $CFG::OPTS{m};
    }
    if($CFG::OPTS{n}) {
      $CFG::NOAUTOSTART = 1;
    }
    if($CFG::OPTS{p}) {
      $CFG::START = 1;
    }
    if($CFG::OPTS{r}) {
      unless(grep { $CFG::OPTS{r} eq $_ } (5..6)) {
	die("Valid values for the -r option are 5 and 6.\n");
      }
      $CFG::RHEL_V = $CFG::OPTS{r};
    }
    if($CFG::OPTS{s}) {
      $CFG::USR_LOCAL_SIZE = $CFG::OPTS{s};
    }
  } elsif($CFG::CALLED_AS eq 'mvvm') {
    &getopts('dhtv', \%CFG::OPTS);
  } elsif($CFG::CALLED_AS eq 'rmvm') {
    &getopts('dhtv', \%CFG::OPTS);
  } elsif($CFG::CALLED_AS eq 'lsvm') {
    &getopts('cdhtv', \%CFG::OPTS);
    if($CFG::OPTS{c}) {
      $CFG::LSVM_CSS = 1;
    }
  } elsif($CFG::CALLED_AS eq 'allvm') {
    &getopts('dhtv', \%CFG::OPTS);
  } elsif($CFG::CALLED_AS eq 'rebuild_stemcell') {
    &getopts('ac:dhm:nr:s:tv', \%CFG::OPTS);
    if($CFG::OPTS{c}) {
      unless($CFG::KVM) {
	if(($CFG::OPTS{c} != 1) && ($CFG::OPTS{c} != 2)) {
	  die("Valid values for the -c option are 1 and 2.\n");
	}
      }
      $CFG::NUMVCPUS = $CFG::OPTS{c};
    }
    if($CFG::OPTS{m}) {
      $CFG::MEM_SIZE = $CFG::OPTS{m};
    }
    if($CFG::OPTS{n}) {
      $CFG::NOAUTOSTART = 1;
    }
    if($CFG::OPTS{r}) {
      unless(grep { $CFG::OPTS{r} eq $_ } (5..6)) {
	die("Valid values for the -r option are 5 and 6.\n");
      }
      $CFG::RHEL_V = $CFG::OPTS{r};
    }
    if($CFG::OPTS{s}) {
      $CFG::USR_LOCAL_SIZE = $CFG::OPTS{s};
    }
  } elsif(($CFG::CALLED_AS eq 'vmup')
	  || ($CFG::CALLED_AS eq 'vmdown')) {
    &getopts('dhtv', \%CFG::OPTS);
  }
  # Universal options
  if($CFG::OPTS{d}) {
    $CFG::DEBUG_MODE = 1;
  }
  if($CFG::OPTS{h}) {
    &main::HELP_MESSAGE();
    exit(0);
  }
  if($CFG::OPTS{t}) {
    $CFG::TEST_MODE = 1;
  }
  if($CFG::OPTS{v}) {
    &main::VERSION_MESSAGE();
    exit(0);
  }
}

sub vm_host_type() {
  # Returns a VM host type:
  # * 'vmw' for VMWare with individual LVs for each VM
  # * 'vmf' for VMWare with a flat LV for all VMs
  # * 'kvm' for KVM

  # If $CFG::KVM is 1, it's kvm -- this test was performed earlier
  if($CFG::KVM) {
    return 'kvm';
  }

  # At this point it must be VMWare, but which configuration?

  # If $CFG::VM_DIR is a volume of its own, then it's vmf
  if(system("df $CFG::VM_DIR >& /dev/null") >> 8) {
    return 'vmw';
  }
  return 'vmf';
}

sub vm_lvs_tag() {
  # Prints the logical volume names of all LVs with the "vm" tag

  system('lvs --noheadings --separator : -o lv_name,lv_tags | grep :vm$ | sed -e "s/^ *//" | cut -d : -f 1 | sort');
}

sub dns_resolve($) {
  # Given a hostname, returns the IP address of the first A record, or undef if
  # not found.
  my($host) = @_;
  my $res = Net::DNS::Resolver->new();
  my $pac = $res->search($host);
  return undef unless defined($pac);
  my $result = undef;
  my @answers = $pac->answer();
  foreach my $ans (@answers) {
    if($ans->type() eq 'A') {
      $result = $ans->rdatastr();
      last;
    }
  }
  return $result;
}

sub vol_space_left() {
  # Prints the amount of space left on the given volume, in bytes
  my($vol) = @_;

  return 0 unless($vol);
  my @line = split(/\s+/, `df -B 1 $vol | tail -n 1`);
  return $line[3];
}

sub test_vol_space() {
  # Given a number of bytes, see if there is at least that much space left on
  # volume $CFG::VM_DIR.  Return 1 if so, '' if not.

  my($need) = @_;
  my $room = &vol_space_left($CFG::VM_DIR);
  return($room >= $need);
}

sub vg_space_left() {
  # Returns the amount of space remaining on $CFG::VM_VG, in bytes

  my @vginfo = split(/:/, `vgdisplay -c $CFG::VM_VG`);
  # Size of a physical extent, in KB:
  my $pe_size = $vginfo[12];
  # Number of free physical extents:
  my $pe_free = $vginfo[15];

  return($pe_free * $pe_size * 1024);
}

sub test_vg_space() {
  # Given a number of bytes, see if there is at least that much space left on
  # volume group $CFG::VM_VG.  Return 1 if so, '' if not.

  my($need) = @_;
  my $room = &vg_space_left();

  return($room >= $need);
}

# Now we have a bunch of math routines that deal with DAs.  Remember, a DA is
# just a quantity with a unit appended.  But we have to be able to do math with
# them and convert units.

sub lvm_to_da() {
  # If necessary, converts the argument from LVM units into our internal system
  # for stating data amounts.  It's pretty easy to tell when it's in LVM units
  # -- the unit is just one character, while the internal system we're using
  # uses either two or three characters for its units.  This function removes
  # all spaces from the argument (thus showing mercy if there's a space between
  # the number and the unit), changes the unit abbreviation if necessary, and
  # puts everything into lowercase for easier matching later.

  my($da) = @_;
  $da =~ s/\s+//g;
  my($number, $unit) = ($da =~ /^(\d+)(\D+)$/);

  # Default is MiB
  unless($unit) {
    $unit = 'mib';
  }

  # Translate from LVM units
  if(length($unit) == 1) {
    my(%lvm2da) =
      (
       E => 'eib',
       P => 'pib',
       G => 'gib',
       M => 'mib',
       K => 'kib',
       e => 'eb',
       p => 'pb',
       t => 'tb',
       g => 'gb',
       m => 'mb',
       k => 'kb',
      );
    if(exists($lvm2da{$unit})) {
      $unit = $lvm2da{$unit};
    } else {
      $unit = 'mib';
    }
  }

  # We keep the unit in lowercase internally
  $unit = lc($unit);
  printf("DEBUG: \$unit = %s\n", $unit) if($CFG::DEBUG_MODE);

  # Test the unit for intelligibility.

  # Does it end with something other than a 'b'?
  unless(substr($unit, -1, 1) eq 'b') {
    die("Unable to understand data amount '$da'.\n");
  }
  # Is it more than 3 or fewer than 2 characters long?
  if((length($unit) > 3) || (length($unit) < 2)) {
    die("Unable to understand data amount '$da'.\n");
  }
  # Does it start with something other than one of the unit prefixes?
  if(substr($unit, 0, 1) !~ /[eptgmk]/) {
    die("Unable to understand data amount '$da'.\n");
  }

  return "$number$unit";
}

sub lvm_unit() {
  # Turns an SI/IEEE1541 unit into an LVM unit.  For example, "MB" should
  # become "m", while "MiB" should become M.  LVM uses its own crazy unit
  # abbrevs.

  my($si_unit) = @_;
  my $lc_si_unit = lc($si_unit);
  my $lvm_unit = substr($lc_si_unit, 0, 1);

  # If it's 3 characters, it must be an IEEE1541 unit and should just be the
  # first letter of that unit, capitalized.  But it's already the first letter
  # of the unit, so we just have to capitalize it.
  if(length($si_unit) == 3) {
    $lvm_unit = uc($lvm_unit);
  }

  # If it's just 2 characters, then it's an SI unit and should just be the
  # first letter of that unit, uncapitalized, and it already is, so nothing
  # more needs to be done.  If it's any other length, then something really
  # weird is in there, so just use M.
  elsif(length($si_unit) != 2) {
    $lvm_unit = 'M';
  }
  return $lvm_unit;
}

sub da_to_lvm() {
  # Converts the given DA's unit to LVM unit names (e.g. "32mb" becomes "32m",
  # and "32mib" becomes "32M")

  my($da) = @_;
  my($number, $unit) = ($da =~ /^(\d+)(\D+)$/);
  my $lunit = &lvm_unit($unit);

  return "$number$lunit";
}

sub unit_mult() {
  # Takes an internal unit (e.g. "gib", "mb", etc.) and returns the multiplier
  # value of that unit (e.g. "unit_mult kb" would return 1000).

  my($unit) = @_;
  my(%mult) =
    (
     eib => 1152921504606846976,
     pib => 1125899906842624,
     tib => 1099511627776,
     gib => 1073741824,
     mib => 1048576,
     kib => 1024,
     eb => 1000000000000000000,
     pb => 1000000000000000,
     tb => 1000000000000,
     gb => 1000000000,
     mb => 1000000,
     kb => 1000,
    );
  # If an "LVM unit" sneaks in here, translate to this script's internal
  # format.
  if($unit =~ /^[kmgtpe]$/) {
    $unit .= 'b';
  } elsif($unit =~ /^[KMGTPE]$/) {
    $unit = lc($unit).'ib';
  }
  if(exists($mult{$unit})) {
    return $mult{$unit};
  } else {
    return $mult{mib};
  }
}

sub da_to_bytes() {
  # Turns its argument, which should be a data amount in the proper internal
  # format (e.g. "32gib"), into bytes.

  my($da) = @_;
  my($number, $unit) = ($da =~ /^(\d+)(\D+)$/);

  return($number * &unit_mult($unit));
}

sub da_to_kib() {
  # Turns its argument, which should be a data amount in the proper internal
  # format (e.g. "32gib"), into KiB.  Rounds up to the nearest KiB.

  my($da) = @_;
  my $bytes = &da_to_bytes($da);
  return POSIX::ceil($bytes/1024);
}

sub da_to_mib() {
  # Turns its argument, which should be a data amount in the proper internal
  # format (e.g. "32gib"), into MiB.  Rounds up to the nearest MiB.

  my($da) = @_;
  my $bytes = &da_to_bytes($da);
  return POSIX::ceil($bytes/1048576);
}

sub da_to_gib() {
  # Turns its argument, which should be a data amount in the proper internal
  # format (e.g. "32tib"), into GiB.  Rounds up to the nearest GiB.

  my($da) = @_;
  my $bytes = &da_to_bytes($da);
  return POSIX::ceil($bytes/1073741824);
}

sub da_to_sectors() {
  # Turns its argument, which should be a data amount in the proper internal
  # format (e.g. "32gib") into VMware format, which has to be in sectors (512
  # bytes), Kb, Mb, or Gb.  Yes, those are the only units it supports.
  # VMware's virtual disks cannot be less than 100 Mb or more than 950 Gb.  I
  # am assuming that VMware's disks use powers-of-10 units.  For optimal
  # accuracy I'm just converting everything into sectors.

  my($da) = @_;
  my $bytes = &da_to_bytes($da);
  return POSIX::ceil($bytes/512);
}

sub da_add() {
  # Takes two data amounts (e.g. "32gib") and adds them, in rudimentary
  # fashion.  The result will be in whatever unit the first argument is in,
  # with fractions dropped.  So `da_add "1gib" "1mib"` produces "1gib", while
  # `da_add "1mib" "1gib"` produces "1025mib".

  my($a, $b) = @_;
  my($unita) = ($a =~ /(\D+)$/);
  my $multa = &unit_mult($unita);
  my $tbytes = &da_to_bytes($a) + &da_to_bytes($b);
  return sprintf('%d%s', POSIX::floor($tbytes/$multa), $unita);
}

sub da_coef() {
  # Multiplies a coefficient into a data amount -- the coefficient is just an
  # integer and should be the first argument, followed by the data amount.

  my($coef, $da) = @_;
  my($number, $unit) = ($da =~ /^(\d+)(\D+)$/);
  return sprintf('%d%s', $coef*$number, $unit);
}

sub da_minimal_base10_unit() {
  # Given a da specifier (e.g. "32gib"), find the minimal powers-of-10 unit
  # that the quantity of data can be expressed in without being all fractional.

  my($da) = @_;
  my $da_bytes = &da_to_bytes($da);
  my($um, $unit);

  foreach $unit (qw(eb pb tb gb mb kb)) {
    my $um = &unit_mult($unit);
    last if($um < $da_bytes);
  }
  return sprintf('%g%s', $da_bytes/$um, $unit);
}

sub da_minimal_base2_unit() {
  # Given a da specifier (e.g. "32gib"), find the minimal powers-of-2 unit that
  # the quantity of data can be expressed in without being all fractional.

  my($da) = @_;
  my $da_bytes = &da_to_bytes($da);
  my($um, $unit);

  foreach $unit (qw(eib pib tib gib mib kib)) {
    my $um = &unit_mult($unit);
    last if($um < $da_bytes);
  }
  return sprintf('%g%s', $da_bytes/$um, $unit);
}

# Now some functions about making ext2/3 labels for filesystems.

sub get_partition_ext2_labels() {
  # Returns the ext2/3 filesystem labels of all partitions.

  my @parts = `fdisk -l | grep ^/dev | cut -d ' ' -f 1`;
  chomp(@parts);
  my @labels = ();
  foreach my $part (@parts) {
    pushd(@labels, `e2label $part`);
  }
  chomp(@labels);
  return(@labels);
}

sub get_lv_ext2_labels() {
  # Returns the ext2/3 filesystem labels of all LVM logical volumes.

  my @lvs = `lvs --noheadings -o vg_name,lv_name | sed -e "s/[[:space:]]\+/\//g"`;
  chomp(@lvs);
  my @labels = ();
  foreach my $lv (@lvs) {
    pushd(@labels, `e2label /dev$lv`);
  }
  chomp(@labels);
  return(@labels);
}

sub get_existing_ext2_labels() {
  # Makes a list of all the ext2 labels that exist on the system, either as
  # partitions or LVs.

  return(&get_partition_ext2_labels(), &get_lv_ext2_labels());
}

sub make_ext2_label() {
  # Given a proposed label, see if there are any ext2/3 filesystems with that
  # label already; if so, vary it with numbers until we find one that is
  # unique.  Remember that ext2/3 filesystem labels can be a maximum of 16
  # characters.  Echo the label we come up with before exiting.

  # There are really 2 potential problems this function is meant to overcome.
  # First is the prolem where the label is too long (more than 16 characters),
  # and the other is the problem where the label is nonunique (some other
  # ext2/3 filesystem exists with the same label).

  my($plabel) = @_;

  my @labels = &get_existing_ext2_labels();
  my $unique = 1;
  my $number = 1;

  # If the proposed label is too long, that won't work for us, so first let's
  # just try using the first 16 characters of the label.

  my $label = substr($plabel, 0, 16);

  # Now let's make sure it's unique.

  if(grep { $_ eq $label } @labels) {
    do {
      # Try adding $number to the end (after shortening it enough to fit)
      $label = substr($plabel, 0, 16 - length($number)).$number;
    } while(grep { $_ eq $label } @labels);
  }
  return $label;
}

# Now we have some utility functions dealing with actual VMs.

sub vm_running() {
  # See if the given VM is running.

  # For KVM, this is done by issuing the command "virsh domstate <VM name>",
  # whose output is one of:

  # crashed (kernel crashed, and VM is configured not to restart on crash)
  # dying (in process of either crash or ungraceful shutdown)
  # idle (not running: either waiting on I/O or asleep because of inactivity)
  # paused (by "virsh suspend")
  # running (it's running -- the only state that returns true from this subroutine)
  # shut off (either it's been shut down or it hasn't been started)
  # shutdown (in process of shutting down gracefully)

  # For VMware, this is done by issuing the command
  # "vmware-cmd <.vmx file> getstate", whose output is one of:

  # getstate() = on
  # getstate() = off

  # A return value of 1 means the VM is running.  A return value of '' means
  # that it is not.

  my($name) = @_;

  return '' if($CFG::TEST_MODE);
  if($CFG::KVM) {
    my $state = `virsh domstate $name`;
    if(($? >> 8) != 0) {
      die("Error: VM '$name' does not exist\n");
    }
    chomp($state);
    chomp($state);
    printf("DEBUG: \$state = '%s'\n", $state) if($CFG::DEBUG_MODE);
    if($state eq 'running') {
      return 1;
    } else {
      return '';
    }
  } else { # VMware
    my $vmxpath = "$CFG::VM_DIR/$name/$name.vmx";
    unless(-e $vmxpath) {
      die("Error: File $vmxpath does not exist\n");
    }
    my $state = `/usr/bin/vmware-cmd $vmxpath getstate 2> /dev/null | sed -re 's/^.*=[[:space:]]*//'`;
    chomp($state);
    printf("DEBUG: \$state = '%s'\n", $state) if($CFG::DEBUG_MODE);
    if($state eq 'on') {
      return 1;
    } else {
      return '';
    }
  }
}

sub set_owners_perms() {
  # Set the ownerships and permissions of the files in a VMware directory to
  # satisfactory values for our purposes.

  my($vmdir) = @_;

  &test_cmd("chgrp -R vm $CFG::VM_DIR/$CFG::VM_NAME");
  &test_cmd("chmod g+rwxs $CFG::VM_DIR/$CFG::VM_NAME");
  &test_cmd("chmod u+x $CFG::VM_DIR/$CFG::VM_NAME/$CFG::VM_NAME.vmx");
  # This process just overlays each file's user permissions onto its group
  # permissions -- if the user can read, the group will be able to read, etc.
  # If for some reason the group can write, for example, but the user cannot,
  # it doesn't change that.
  &test_cmd("find $CFG::VM_DIR/$CFG::VM_NAME -perm -u+r -exec chmod g+r {} \\;");
  &test_cmd("find $CFG::VM_DIR/$CFG::VM_NAME -perm -u+w -exec chmod g+w {} \\;");
  &test_cmd("find $CFG::VM_DIR/$CFG::VM_NAME -perm -u+x -exec chmod g+x {} \\;");
}

sub register_vm() {
  # Tell VMware to open this VM and add it to its inventory.

  my($vm) = @_;

  &test_cmd("vmware-cmd -s register $CFG::VM_DIR/$vm/$vm.vmx 2> /dev/null");
}

sub unregister_vm() {
  # Tell VMware to remove this VM from its inventory.

  my($vm) = @_;

  &test_cmd("vmware-cmd -s unregister $CFG::VM_DIR/$vm/$vm.vmx 2> /dev/null");
}

sub modify_vmxfile {
  # Edits a .vmx file, changing parameters to the given values.  Parameters in
  # .vmx files look like:
  #
  # parameter = "value"
  #
  # The first parameter to this function should be the path to the .vmx file.
  # After that, the parameters should be in pairs, with the name and value of
  # each parameter coming right after the other.  If a parameter exists in the
  # .vmx file already, its value will of course be replaced with the new value.
  # Otherwise, the new parameter will be added to the end.  Note that there is
  # no way for this function to discriminate between valid and invalid
  # parameters -- VMware has never been very forthcoming about documenting
  # these parameters, and the VMware Server 1.x documentation is no longer
  # available from their web server.  Some useful parameters:
  #
  # displayname: the name of the VM; VMware refers to it by this name
  # autostart: whether the VMware server should start this VM automatically
  # ("poweron") or not ("none")
  # memsize: the amount of RAM available to the VM, measured in MiB
  # numvcpus: the number of virtual CPUs (1 or 2)
  # machine.id: a string that can be retrieved by vmware-guestd within the
  # guest via the command: vmware-guestd --cmd 'machine.id.get'
  # guestinfo.<any>: a string that can be retrieved by vmware-guestd within the
  # guest via a command of the form: vmware-guestd --cmd 'info-get
  # guestinfo.<any>'
  #
  # The previous .vmx file will be left as *.vmx.bak.

  my $vmxfile = shift(@_);
  my %changes = @_;
  my %existed = ();
  &test_cmd("mv $vmxfile $vmxfile.bak");
  if($CFG::TEST_MODE) {
    printf("(test mode) modify %s\n", $vmxfile);
    return;
  }
  my $rh = IO::File->new();
  $rh->open("<$vmxfile.bak") || die("Unable to open $vmxfile.bak for reading: $!\n");
  my $wh = IO::File->new();
  $wh->open(">$vmxfile") || die("Unable to open $vmxfile for writing: $!\n");
  my $line;
  # Read $vmxfile.bak line by line, printing output to $vmxfile
  while(defined($line = <$rh>)) {
    chomp($line);
    unless(($line =~ /^\s*#/) || ($line =~ /^\s*$/)) { # Ignore comments/blank lines
      # Get the parameter name
      my($key) = ($line =~ /^\s*([^\s=]+)/);
      # If this parameter is being changed, remember it in %existed and rewrite $line
      if(exists($changes{$key})) {
	$existed{$key} = 1;
	$line = sprintf('%s = "%s"', $key, $changes{$key});
      }
    }
    $wh->printf("%s\n", $line);
  }
  # Any parameters in %changes that didn't exist in the file should be added to the end
  foreach my $key (keys(%changes)) {
    unless($existed{$key}) {
      $wh->printf("%s = \"%s\"\n", $key, $changes{$key});
    }
  }
  $wh->close();
  $rh->close();
}

sub vm_name_valid() {
  # Tests the proposed VM name to make sure it's legal for LVM.  LVM doesn't
  # allow VG or LV names with any characters other than letters numbers, and
  # _.+-.  Returns 1 if all is well, 0 otherwise.

  my($name) = @_;

  return '' unless(defined($name));
  return '' if($name eq '');
  if($name =~ /[^-a-z0-9_.+]/) {
    return '';
  } else {
    return 1;
  }
}

sub vm_name_exists() {
  # Checks whether a VM already exists under the given name, or does not.  If
  # it does, return true (1).  If not, return false ('').  If $supposed_to is
  # true, print warning messages based on the assumption that it should exist
  # (i.e. if it doesn't, warn).  If $supposed_to is false, warn if the VM does
  # exist.

  my($vm_name, $supposed_to) = @_;

  return($supposed_to) if($CFG::TEST_MODE);
  # If it's KVM, see if there's a VM with that name.
  if($CFG::KVM) {
    if((system("virsh dominfo $vm_name >& /dev/null") >> 8) == 0) {
      warn("A VM named $vm_name already exists.\n") unless($supposed_to);
      return 1;
    } else {
      warn("No VM named $vm_name exists.\n") if($supposed_to);
      return '';
    }
  }
  # Flat VMware is easier.  But let's test for some pathological cases possible
  # with non-flat VMware first.
  if($CFG::VM_HOST_TYPE eq 'vmw') {
    # Look for an LV named $vm_name.
    if((system("lvdisplay /dev/$CFG::VM_VG/$vm_name >& /dev/null") >> 8) == 0) {
      unless($supposed_to) {
	warn("A logical volume named /dev/$CFG::VM_VG/$vm_name already exists.\n");
	return 1;
      }
    } else {
      if($supposed_to) {
	warn("No logical volume named /dev/$CFG::VM_VG/$vm_name exists.\n");
	return '';
      }
    }
    # Look for a mount point named $vm_name.
    if(-e "$CFG::VM_DIR/$vm_name") {
      unless($supposed_to) {
	warn("$CFG::VM_DIR/$vm_name already exists.\n");
	return 1;
      }
    } else {
      if($supposed_to) {
	warn("$CFG::VM_DIR/$vm_name does not exist.\n");
	return '';
      }
    }
    # Look for an /etc/fstab entry for $vm_name.
    if((system("grep -Eq ^[^[:space:]]+[[:space:]]+$CFG::VM_DIR/$vm_name/?[[:space:]] /etc/fstab") >> 8) == 0) {
      unless($supposed_to) {
	warn("There is an entry in /etc/fstab for $CFG::VM_DIR/$vm_name.\n");
	return 1;
      }
    } else {
      if($supposed_to) {
	warn("There is no entry in /etc/fstab for $CFG::VM_DIR/$vm_name.\n");
	return '';
      }
    }
  }
  # Then there are problems that can occur on any VMware host, flat or not.
  # For example, there might be a .vmx file with the name.
  if((system("ls $CFG::VM_DIR/*/$vm_name.vmx >& /dev/null") >> 8) == 0) {
    unless($supposed_to) {
      my $where = `ls $CFG::VM_DIR/*/$vm_name.vmx`;
      chomp($where);
      warn("$where already exists.\n");
      return 1;
    }
  } else {
    if($supposed_to) {
      warn("Cannot find $CFG::VM_DIR/*/$vm_name.vmx.\n");
      return '';
    }
  }
  # One last crazy check.  There might be a VM with everything else different
  # but with the same displayname.
  if((system("grep -Eiq '^[[:space:]]*displayname[[:space:]]*=[[:space:]]*\"$vm_name\"' $CFG::VM_DIR/*/*.vmx") >> 8) == 0) {
    unless($supposed_to) {
      warn("The following .vmx files define VMs named '$vm_name':\n");
      system("grep -Eil '^[[:space:]]*displayname[[:space:]]*=[[:space:]]*\"$vm_name\"' $CFG::VM_DIR/*/*.vmx > /dev/stderr");
      return 1;
    }
  } else {
    if($supposed_to) {
      warn("No .vmx file in $CFG::VM_DIR/*/*.vmx defines a VM named '$vm_name'.\n");
      return '';
    }
  }
  # At this point it certainly looks as if the proposed VM is how it's supposed
  # to be.
  return $supposed_to?1:'';
}

sub vm_name_ok() {
  # Make sure a proposed VM name is OK -- is it valid?  Does it already exist?
  # If all is well, return true.  If not, return false.

  my($vm_name) = @_;
  if(&vm_name_valid($vm_name) && !&vm_name_exists($vm_name, '')) {
    return 1;
  } else {
    return '';
  }
}

sub have_enough_space {
  # Make sure the size of the /usr/local disk makes sense, we have space for
  # it, etc.  If all is well, returns true.  Affects $CFG::USR_LOCAL_SIZE.

  # Make sure the size is intelligible
  $CFG::USR_LOCAL_SIZE = &lvm_to_da($CFG::USR_LOCAL_SIZE);
  # Make sure we have enough space
  my $usr_local_size_bytes = &da_to_bytes($CFG::USR_LOCAL_SIZE);
  my $other_data_bytes = &da_to_bytes($CFG::BASE_VM_SIZE);
  my $total_bytes = $usr_local_size_bytes + $other_data_bytes;
  my $vm_size_bytes = $total_bytes*2;
  my $is_enough_space;
  my $space_left_bytes;

  # Test whether there is enough space -- on the volume group if "old style"
  # VMware, or on the volume itself if "flat" VMware or if KVM.
  if(($CFG::VM_HOST_TYPE eq 'vmf') || ($CFG::VM_HOST_TYPE eq 'kvm')) {
    $is_enough_space = &test_vol_space($vm_size_bytes);
    $space_left_bytes = &vol_space_left($CFG::VM_DIR);
  } else {
    $is_enough_space = &test_vg_space($vm_size_bytes);
    $space_left_bytes = &vg_space_left();
  }
  unless($is_enough_space) {
    if(($CFG::VM_HOST_TYPE eq 'vmf') || ($CFG::VM_HOST_TYPE eq 'kvm')) {
      warn("Not enough room left on volume $CFG::VM_DIR\n");
    } else {
      warn("Not enough room left on volume group $CFG::VM_VG\n");
    }
    warn(sprintf("%.0f MiB left; requires %.0f\n",
		 $space_left_bytes/1048576,
		 $vm_size_bytes/1048576));
    return '';
  }

  # Test whether the requested size is outside the supported limits of the
  # virtual disk system.  VMware Server 1.x's documentation states limits of no
  # less than 100.0 MB and no greater than 950.0 GB.  I am uncertain what the
  # limits of the KVM virtual disk format that we're using (QCOW2) are.
  if(substr($CFG::VM_HOST_TYPE, 0, 2) eq 'vm') {
    # Check the $CFG::USR_LOCAL_SIZE to make sure it's not too big or small
    # (VMware's stated limits are [100.0 MB, 950.0 GB])
    if(($usr_local_size_bytes < 100000000) ||
       ($usr_local_size_bytes > 950000000000)) {
      warn("Virtual disk /usr/local cannot be smaller than 100 MB or larger than 950 GB\n");
      return '';
    }
  }

  # Things seem OK
  return 1;
}

sub have_x11() {
  # Returns true if we have X11; false otherwise.
  if((system("xset q >& /dev/null") >> 8) == 0) {
    return 1;
  } else {
    return '';
  }
}

sub create_vdisk_img {
  # Creates a virtual disk image in the current directory with the given name
  # and size (normally a data amount in G, such as "32G").  If $CFG::KVM,
  # create a QCOW2 (QEMU Cache-on-Write 2) image; otherwise, create a VMware
  # image.  Creates a partition on the disk image and makes a filesystem in
  # that partition (ext3 for RHEL <=5, ext4 for RHEL >= 6).

  # The filesystem will get the specified label or "/usr/local" by default.  It
  # will also get the specified blocksize (only values of 1024, 2048, and 4096
  # are allowed) unless nothing is specified, in which case 1024 is the
  # default.

  my($filename, $size, $label, $blocksize) = @_;
  unless($filename) {
    # This would be a programming error.
    warn("Empty virtual disk filename.\n");
    exit 1;
  }
  unless($size) {
    # This would also be a programming error.
    warn("No virtual disk size given.\n");
    exit 1
  }
  $label ||= '/usr/local';
  $blocksize ||= 1024;
  # Only these values are allowed for the block size in ext2/3/4 filesystems.
  if(($blocksize != 1024) && ($blocksize != 2048) && ($blocksize != 4096)) {
    $blocksize ||= 1024;
  }
  my $fs = ($CFG::RHEL_V <= 5)?'ext3':'ext4';
  if($CFG::KVM) {
    # For KVM, we create it with qemu-img create, then use guestfish to
    # directly partition it and make a filesystem on it.
    print("Creating QCOW2 disk image $filename ...\n");
    &test_cmd("qemu-img create -f qcow2 -o size=$size,preallocation=metadata $filename");
    print("Creating partition and filesystem ...\n");
    &test_cmd("guestfish add $filename : run : part-disk /dev/vda gpt : mkfs-opts $fs /dev/vda1 blocksize:$blocksize : set-e2label /dev/vda1 $label");
    &test_cmd("chown qemu:qemu $filename");
  } else {
    # For VMware, we make a raw disk image, partition it, make a filesystem on
    # it, and convert it using "qemu-img convert".  VMware (or, at least,
    # VMware Server 1.x) has no utilities for accessing the data within a .vmdk
    # virtual disk image file or converting other types of disk images to .vmdk
    # files.  However, the qemu-img command can convert between disk image
    # formats, and it exists for RHEL 5.  This process is based on an idea by
    # Soichi Hayashi (hayashis@iu.edu).
    my $size_m = &da_to_mib($size);
    # Make the raw disk image
    my $tempdir;
    if($CFG::TEST_MODE) {
      # In test mode, the VM-specific directory hasn't been made, and we don't
      # want to create an actual tempdir, so just make up a fictional one.
      $tempdir = "$CFG::VM_DIR/$CFG::VM_NAME/tempdir";
    } else {
      $tempdir = File::Temp->tempdir('mkvm.XXXXXXXX', DIR => "$CFG::VM_DIR/$CFG::VM_NAME", CLEANUP => 1);
    }
    my $tempdisk = "$tempdir/tempdisk.img";
    print("Creating raw disk image $tempdisk of size ${size_m}M ...\n");
    &test_cmd("dd if=/dev/zero of=$tempdisk bs=1048576 count=${size_m} > /dev/null");
    # Partition the raw disk image
    print("Creating partition within $tempdisk ...\n");
    &test_cmd("parted $tempdisk mktable gpt mkpart primary ext3 '0%' '100%'");
    print("Creating filesystem within partition ...\n");
    # Find out where that partition starts and how big it is
    my($partoffset_b, $partsize_b);
    if($CFG::TEST_MODE) {
      # Make up some reasonable-ish values for testing
      $partoffset_b = 16384;
      $partsize_b = 1048576*$size_m - $partoffset_b;
    } else {
      my @partout = grep { /^\s*\d/ } `parted $tempdisk unit b print`;
      ($partoffset_b, $partsize_b) = ($partout[0] =~ /^\s*\d+\s+(\d+)B\s+\d+B\s+(\d+)B/);
    }
    # Define the image as a loopback device with the offset just discovered
    &test_cmd("losetup -f -o $partoffset_b $tempdisk");
    my $loopdev;
    if($CFG::TEST_MODE) {
      $loopdev = '/dev/loop0';
    } else {
      my @lout = grep { m!\($tempdisk\)! } `losetup -a`;
      ($loopdev) = ($lout[0] =~ /^([^:]+)/);
    }
    # Make a filesystem on that loopback device
    my $blocks = sprintf("%d", $partsize_b/$blocksize);
    &test_cmd("mkfs -t $fs -L $label -b $blocksize $loopdev $blocks > /dev/null");
    # Release the loopback device; we're done with it
    &test_cmd("losetup -d $loopdev");
    # Convert the partition to VMware
    printf("Converting disk image to vmdk ...\n");
    &test_cmd("qemu-img convert -f raw $tempdisk -O vmdk $filename");
    &test_cmd("chgrp vm $filename");
    # Clean up
    &test_cmd("rm -rf $tempdir");
  }
}

sub prepare_vm_home {
  # Prepares a home for the VM -- in the case of non-flat VMware hosts, this
  # means making a LV, making a filesystem on it, making an /etc/fstab entry
  # for it, making a mount point, and mounting it.  For flat VMware hosts, this
  # just means making a directory for it.  For KVM hosts, this means doing
  # nothing.  Requires $CFG::VM_NAME, $CFG::MEM_SIZE, $CFG::USR_LOCAL_SIZE,
  # etc. to be set.

  # Unless it's KVM, make the mount point
  unless($CFG::KVM) {
    &test_cmd("mkdir $CFG::VM_DIR/$CFG::VM_NAME");
    &test_cmd("chgrp vm $CFG::VM_DIR/$CFG::VM_NAME");
    &test_cmd("chmod g+ws $CFG::VM_DIR/$CFG::VM_NAME");
  }

  # For non-flat VMware, do the necessary stuff
  if($CFG::VM_HOST_TYPE eq 'vmw') {
    # Make the LV
    my $vm_size_lvm = &da_to_lvm(&da_coef(2, &da_add($CFG::BASE_VM_SIZE, $CFG::USR_LOCAL_SIZE)));
    &test_cmd("lvcreate --addtag $CFG::VM_TAG -L $vm_size_lvm -n $CFG::VM_NAME $CFG::VM_VG");

    # Generate the filesystem label
    my $vm_ext2_label = &make_ext2_label($CFG::VM_NAME);

    # Make the filesystem
    &test_cmd("mkfs -t ext3 -L $vm_ext2_label /dev/$CFG::VM_VG/$CFG::VM_NAME");

    # Make a line in /etc/fstab
    &test_cmd("echo 'LABEL=$vm_ext2_label	$CFG::VM_DIR/$CFG::VM_NAME	ext3	defaults	1 2\" >> /etc/fstab");

    # Mount the new volume
    &test_cmd("mount $CFG::VM_DIR/$CFG::VM_NAME");
  }
}

sub install_stemcell {
  # Copies the stemcell from the server and puts things in the right places.

  print("Unpacking stemcell tarball ...\n");
  if($CFG::KVM) {
    &test_cmd("tar zxf $CFG::ARCHIVE_DIR/$CFG::STEMCELL_TARBALL -C /");
  } else {
    &test_cmd("tar zxf $CFG::ARCHIVE_DIR/$CFG::STEMCELL_TARBALL -C $CFG::VM_DIR/$CFG::VM_NAME --strip-components=1");
    # Make the new /usr/local virtual disk
#    my $sectors = &da_to_sectors($CFG::USR_LOCAL_SIZE);
#    &test_cmd(<<"EOF");
#vmware-vdiskmanager -c
#  -a ide
#  -s $sectors
#  -t 0
#  $CFG::VM_DIR/$CFG::VM_NAME/usr_local.vmdk
#EOF
#    ;
  }
  print("Done.\n");
}

sub install_stemcell_classic {
  # Copies the stemcell from the server and puts things in the right places.
  # Only works if this is a VMware host.

  if($CFG::KVM) {
    warn("Cannot use stemcell-classic on KVM hosts.\n");
    return '';
  }
  print("Unpacking stemcell tarball ...\n");
  &test_cmd("tar zxf /net/install/home/sysinstall/stemcell.tgz -C $CFG::VM_DIR/$CFG::VM_NAME --strip-components=1");
  &test_cmd("rename stemcell-classic. stemcell. $CFG::VM_DIR/$CFG::VM_NAME/stemcell-classic.*");
  # Make the new /usr/local virtual disk
#  my $sectors = &da_to_sectors($CFG::USR_LOCAL_SIZE);
#  &test_cmd(<<"EOF");
#vmware-vdiskmanager -c
#  -a ide
#  -s $sectors
#  -t 0
#  $CFG::VM_DIR/$CFG::VM_NAME/usr_local.vmdk
#EOF
#  ;
  print("Done.\n");
}

sub customize_vm {
  # After installing a stemcell (see install_stemcell), customize it to the
  # specifications given in the config file and on the command line.

  # Need short VM name for a few things (i.e. if $CFG::VM_NAME is 'foo.6',
  # $short should be 'foo')
  my($short, $version) = ($CFG::VM_NAME =~ /^(.*)\.(\d+)$/);
  # If there is no version in $CFG::VM_NAME, just use $CFG::VM_NAME.
  $short ||= $CFG::VM_NAME;
  $version ||= 0;

  # Look up IP addresses, if any
  my @suffix = (
		'grid.iu.edu',
		'goc',
	       );
  my @ip = ();
  foreach my $ifnum (0, 1) {
    my $hostname = sprintf('%s.%s', $short, $suffix[$ifnum]);
    my $ip = &dns_resolve($hostname);
    push(@ip, $ip);
  }

  if($CFG::KVM) {
    # Rename the virtual disk files, then modify the XML file in
    # /tmp/$CFG::STEMCELL.xml and import it as whatever it is to be named.

    unless((-e "$CFG::VM_DIR/$CFG::STEMCELL-hda.qcow2") || $CFG::TEST_MODE) {
      die("Something is very wrong: After unpacking $CFG::STEMCELL image,\ndisk image $CFG::VM_DIR/$CFG::STEMCELL-hda.qcow2 does not exist.\nUnable to proceed.\n");
    }
    # Use XML::Twig to modify the XML
    my $t = XML::Twig->new();
    if($CFG::TEST_MODE) {
      # This is taken from a typical KVM XML dump; we're using it so test mode
      # has something to do
      $t->parse(<<"EOF");
<domain type='kvm'>
  <name>$CFG::STEMCELL</name>
  <uuid>951cc26a-bda1-9ffc-3f3c-dff3f37a4524</uuid>
  <memory>1048576</memory>
  <currentMemory>1048576</currentMemory>
  <vcpu>1</vcpu>
  <os>
    <type arch='x86_64' machine='rhel6.2.0'>hvm</type>
    <boot dev='hd'/>
  </os>
  <features>
    <acpi/>
    <apic/>
    <pae/>
  </features>
  <clock offset='utc'/>
  <on_poweroff>destroy</on_poweroff>
  <on_reboot>restart</on_reboot>
  <on_crash>restart</on_crash>
  <devices>
    <emulator>/usr/libexec/qemu-kvm</emulator>
    <disk type='file' device='disk'>
      <driver name='qemu' type='qcow2' cache='none'/>
      <source file='/var/lib/libvirt/images/$CFG::STEMCELL-hda.qcow2'/>
      <target dev='hda' bus='ide'/>
      <address type='drive' controller='0' bus='0' unit='0'/>
    </disk>
    <disk type='file' device='disk'>
      <driver name='qemu' type='qcow2' cache='none'/>
      <source file='/var/lib/libvirt/images/$CFG::STEMCELL-hdb.qcow2'/>
      <target dev='hdb' bus='ide'/>
      <address type='drive' controller='0' bus='0' unit='1'/>
    </disk>
    <controller type='ide' index='0'>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x1'/>
    </controller>
    <interface type='bridge'>
      <mac address='52:54:00:04:00:00'/>
      <source bridge='br0'/>
      <model type='e1000'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/>
    </interface>
    <interface type='bridge'>
      <mac address='52:54:00:06:00:00'/>
      <source bridge='br1'/>
      <model type='e1000'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/>
    </interface>
    <serial type='pty'>
      <target port='0'/>
    </serial>
    <console type='pty'>
      <target type='serial' port='0'/>
    </console>
    <input type='mouse' bus='ps2'/>
    <graphics type='vnc' port='-1' autoport='yes' keymap='en-us'/>
    <video>
      <model type='cirrus' vram='9216' heads='1'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0'/>
    </video>
    <memballoon model='virtio'>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x0'/>
    </memballoon>
  </devices>
</domain>
EOF
      ;
    } else {
      $t->parsefile("/tmp/$CFG::STEMCELL.xml");
    }
    # Modify the XML:
    # VM name
    my($name) = $t->get_xpath('./name[1]');
    $name->set_text($CFG::VM_NAME);

    # UUID -- libvirt won't let any two VMs have the same UUID on the same
    # host.  This is why I'm using "$CFG::VM_NAME.goc" as my domain name -- if
    # we used "$short.goc", one couldn't have "foo.1" and "foo.2" on the same
    # host.
    my($uuid) = $t->get_xpath('./uuid[1]');
    tie my $u, 'OSSP::uuid::tie';
    my $dn = sprintf('CN=%s,OU=VMs,DC=goc', $CFG::VM_NAME);
    $u = [ 'v3', 'ns:X500', $dn ];
    $uuid->set_text($u);

    # System RAM
    my($memory) = $t->get_xpath('./memory[1]');
    $memory->set_text(&da_to_kib($CFG::MEM_SIZE));
    # Not sure what this is, but it should be the same as $memory
    my($currentMemory) = $t->get_xpath('./currentMemory[1]');
    $currentMemory->set_text($memory->text());

    # Number of CPUs
    my($vcpu) = $t->get_xpath('./vcpu[1]');
    $vcpu->set_text($CFG::NUMVCPUS);

    # Whether to start the VM at boot time
    my($on_reboot) = $t->get_xpath('./on_reboot[1]');
    $on_reboot->set_text($CFG::NOAUTOSTART?'destroy':'restart');
    my($on_crash) = $t->get_xpath('./on_crash[1]');
    $on_crash->set_text($CFG::NOAUTOSTART?'destroy':'restart');

    # Network interfaces
    my @interfaces = $t->get_xpath('./devices/interface[@type="bridge"]');
    my %suffix = (
		  br0 => 'grid.iu.edu',
		  br1 => 'goc',
		  );
    foreach my $elt (@interfaces) {
      # The indicator byte's bits mean:
      # & 1: Last two octets randomly generated (vs. IP-based)
      # & 2: This is eth1 (vs. eth0)
      # & 4: This is rebuild_stemcell (vs. mkvm) -- this is mkvm, so it's 0
      # & 8: No auto-networking
      # & 16, 32: VM version
      my $if = $elt->first_child('source')->{att}->{bridge};
      my $mac_indicator = (($if eq 'br1')?2:0) | ($CFG::AUTONET?0:8)
	| (($version & 3) << 4);
      my @last2 = (0, 0);
      my $ip = $ip[substr($if, -1, 1)];
      if(defined($ip)) {
	my @ip_octets = split(/\.+/, $ip);
	@last2 = @ip_octets[2, 3];
      } else {
	$mac_indicator |= 1;	# This bit in the indicator means random @last2
	@last2 = (rand(256), rand(256));
      }
      $elt->first_child('mac')->{att}->{address} =
	sprintf('52:54:00:%02X:%02X:%02X', $mac_indicator, @last2);
    }

    # Disk files
    my @disks = $t->get_xpath('./devices/disk[@type="file"]');
    foreach my $elt (@disks) {
      $elt->first_child('source')->{att}->{file} =~ s/$CFG::STEMCELL/$CFG::VM_NAME/;
    }
    # Will also have to recreate $CFG::STEMCELL-hdb.qcow2 and rename both disk image
    # files
    &create_vdisk_img(sprintf("%s/%s-hdb.qcow2", $CFG::VM_DIR, $CFG::VM_NAME),
		      sprintf("%dG", &da_to_gib($CFG::USR_LOCAL_SIZE)));
    &test_cmd(sprintf('mv %s/%s-hda.qcow2 %s/%s-hda.qcow2',
		      $CFG::VM_DIR, $CFG::STEMCELL, $CFG::VM_DIR, $CFG::VM_NAME));
    &test_cmd('virsh pool-refresh default');

    

    # Now then, write the XML to a file and tell libvirt to import it
    my $tfh = File::Temp->new(TEMPLATE => 'mkvmXXXXXX',
			      DIR => '/tmp',
			      SUFFIX => '.xml');
    $t->set_pretty_print("indented");
    $t->print() if($CFG::DEBUG_MODE);
    $t->print($tfh);
    $tfh->flush();

    # "virsh create" would work if we put the XML file in its final location
    # ourselves, but I don't feel like searching through the libvirt
    # configuration to find the correct directory.  I can't assume it's always
    # going to be /etc/libvirt/qemu forever and ever.  Instead, I'll use "virsh
    # define", which copies the XML to wherever the correct directory is for
    # me.
    &test_cmd(sprintf('virsh define %s', $tfh->filename()));
    $tfh->close();
    &test_cmd("rm -f /tmp/$CFG::STEMCELL.xml");
  } else { # The VMware case
    # Rename .vmx file
    &test_cmd("rename $CFG::STEMCELL. $CFG::VM_NAME. $CFG::VM_DIR/$CFG::VM_NAME/$CFG::STEMCELL.*");
    my $vmxfile = "$CFG::VM_DIR/$CFG::VM_NAME/$CFG::VM_NAME.vmx";

    # Autostart parameter
    my $autostart = $CFG::NOAUTOSTART?'none':'poweron';

    # Get VM host's hostname
    my @hostparts = split(/\./, $ENV{HOSTNAME}, 2);
    my $shorthost = $hostparts[0];

    # Make Ethernet addresses
    my @macs = ();
    my %suffix = (
		  0 => 'grid.iu.edu',
		  1 => 'goc',
		 );
    foreach my $i (0, 1) {
      # The indicator byte's bits mean:
      # & 1: Last two octets randomly generated (vs. IP-based)
      # & 2: This is eth1 (vs. eth0)
      # & 4: This is rebuild_stemcell (vs. mkvm) -- this is mkvm, so it's 0
      # & 8: No auto-networking
      # & 16, 32: VM version
      my $mac_indicator = (($i == 1)?2:0) | ($CFG::AUTONET?0:8)
	| (($version & 3) << 4);
      my @last2 = (0, 0);
      my $h = gethost(sprintf('%s.%s', $short, $suffix{$i}));
      if($h && $h->name) {
	my @ip_octets = unpack("C4", ${$h->addr_list}[0]);
	@last2 = @ip_octets[2, 3];
      } else {
	$mac_indicator |= 1;	# To review, this bit means random @last2
	@last2 = (rand(256), rand(256));
      }
      $macs[$i] = sprintf('00:50:56:%02X:%02X:%02X', $mac_indicator, @last2);
    }

    # Make the necessary changes to the .vmx file
    &modify_vmxfile($vmxfile,
		    (
		     displayName => $CFG::VM_NAME,
		     autostart => $autostart,
		     memsize => &da_to_mib($CFG::MEM_SIZE),
		     'machine.id' => $shorthost,
		     numvcpus => $CFG::NUMVCPUS,
		     'uuid.action' => 'create',
		     'ethernet0.address' => $macs[0],
		     'ethernet1.address' => $macs[1],
		     'guestinfo.autonet' => $CFG::AUTONET?'1','',
		     'guestinfo.autoinstall' => $CFG::AUTOINSTALL?'1','',
		     'guestinfo.shorthostname' => $short,
		     'guestinfo.vmname' => $CFG::VM_NAME,
		     'guestinfo.rebuildstemcell' => '',
		    ));

    # Create the /dev/hdb disk.
    &create_vdisk_img(sprintf("%s/%s/hdb.vmdk", $CFG::VM_DIR, $CFG::VM_NAME),
		      sprintf("%dG", &da_to_gib($CFG::USR_LOCAL_SIZE)));

    # Tell VMware about the new VM
    &register_vm($CFG::VM_NAME);

    # Set the owner/group/permissions of the new files
    &set_owners_perms("$CFG::VM_DIR/$CFG::VM_NAME");
  }
}

sub fix_vmware_perl_api_errors {
  # Kill off the "Use of uninitialized value" errors
  my $vmperl_start = "/usr/lib64/perl5";
  my $vmperl_name = "VmPerl.pm";
  &test_cmd("find $vmperl_start -name $vmperl_name -print0 | xargs -0 sed -i.bak -re \"s/return Version\\(\\);/return Version() || '';/\"");
}

# Now we finally have the subroutines that handle the commands, with the help
# of all the above subroutines.

sub do_lsvm {
  # List the VMs and whether they're up or down, in a standard format.  The
  # command-line option -c sets $CFG::LSVM_CSS, which causes the output to be
  # in HTML <span> tags, for the 'vmlist' script -- the tags are given class
  # "up" or "down", which the CSS can decide what to do with.

  # We will first be populating @states, then printing output uniformly.
  my @states = ();
  if($CFG::KVM) {
    # List the VMs, removing blank lines and header lines from the output of
    # "virsh list".
    my @vms = grep {
      $_ !~ /^\s*$/
    } grep {
      $_ !~ /^--/
    } grep {
      $_ !~ /^\s*Id/
    } `virsh -r -c qemu:///system list --all`;
    chomp(@vms);
    foreach my $line (@vms) {
      printf("DEBUG: \$line = %s\n", $line) if($CFG::DEBUG_MODE);
      my(undef, undef, $vm, $state) = split(/\s+/, $line);
      my $updown = ($state eq 'running')?'up':'down';
      push(@states, { vm => $vm, state => $updown });
    }
  } else {
    my @vmxes = `vmware-cmd -l`;
    chomp(@vmxes);
    foreach my $vmx (@vmxes) {
      my $dir = dirname($vmx);
      my $vm = basename($dir);
      my $state = `vmware-cmd $vmx getstate | sed -re 's/^.*=[[:space:]]*//'`;
      chomp($state);
      my $updown = ($state eq 'on')?'up':'down';
      push(@states, { vm => $vm, state => $updown });
    }
  }
  # Output: Unless we're using the CSS output format, first determine the
  # longest VM name for formatting.
  my $maxlength = 0;
  unless($CFG::LSVM_CSS) {
    foreach my $rec (@states) {
      my $vml = length($rec->{vm});
      $maxlength = $vml if($vml > $maxlength);
    }
  }
  # Output: Print the results, sorted case-insensitively.
  foreach my $rec (sort { lc($a->{vm}) cmp lc($b->{vm}) } @states) {
    if($CFG::LSVM_CSS) {
      printf("<span class=\"%s\">%s</span>\n", $rec->{state}, $rec->{vm});
    } else {
      printf("%-${maxlength}s %s\n", $rec->{vm}, $rec->{state});
    }
  }
}

sub do_mkvm {
    # Make a VM.

  unless($ENV{USER} eq 'root') {
    die("Must be root.\n");
  }

  if($CFG::KVM) {
    unless(&have_x11()) {
      die("Creating VMs requires X11.  Be sure it is enabled.\n");
    }
  }

  $CFG::VM_NAME = $ARGV[0];

  # Test the proposed name.
  unless(&vm_name_ok($CFG::VM_NAME)) {
    warn("Unable to proceed.\n");
    if($CFG::VM_NAME eq '') {
      &main::HELP_MESSAGE();
    }
    exit 1;
  }

  # Test the proposed size of the /usr/local disk.
  unless(&have_enough_space()) {
    die("Unable to proceed.\n");
  }

  # Similarly with the memory size -- but if $CFG::MEM_SIZE is not set, that
  # must mean that we're taking the memory size from the stemcell VM, so leave
  # it unset in that case
  if($CFG::MEM_SIZE) {
    $CFG::MEM_SIZE = &lvm_to_da($CFG::MEM_SIZE);
  }

  # If you can think of any more reasons why we shouldn't go ahead and make the
  # VM, put them before this point

  # Make a landing zone for the VM
  &prepare_vm_home();

  # Put the VM there
  &install_stemcell();

  # Customize the VM
  &customize_vm();

  # Start the VM
  &do_start($CFG::VM_NAME) if($CFG::START);
}

sub do_mkvm_classic {
    # Make a VM the "classic" way.  This means to get it from /home/sysinstall
    # on dubois, and be aware that the archive uses main directory
    # stemcell-classic rather than just stemcell.  Cannot do this on KVM hosts,
    # because there has never been a mechanism for making a "classic" stemcell
    # image for KVM.

  if($CFG::KVM) {
    die("Cannot use mkvm_classic on KVM hosts.\n");
  }

  unless($ENV{USER} eq 'root') {
    die("Must be root.\n");
  }

  $CFG::VM_NAME = $ARGV[0];

  # Test the proposed name.
  unless(&vm_name_ok($CFG::VM_NAME)) {
    warn("Unable to proceed.\n");
    if($CFG::VM_NAME eq '') {
      &main::HELP_MESSAGE();
    }
    exit 1;
  }

  # Test the proposed size of the /usr/local disk.
  unless(&have_enough_space()) {
    die("Unable to proceed.\n");
  }

  # Similarly with the memory size -- but if $CFG::MEM_SIZE is not set, that
  # must mean that we're taking the memory size from the stemcell VM, so leave
  # it unset in that case
  if($CFG::MEM_SIZE) {
    $CFG::MEM_SIZE = &lvm_to_da($CFG::MEM_SIZE);
  }

  # If you can think of any more reasons why we shouldn't go ahead and make the
  # VM, put them before this point

  # Make a landing zone for the VM
  &prepare_vm_home();

  # Put the VM there
  &install_stemcell_classic();

  # Customize the VM
  &customize_vm();

  # Start the VM
  &do_start($CFG::VM_NAME) if($CFG::START);
}

sub preserve_old_tarball() {
  # Retain a few old stemcell tarballs.  Old tarballs will use Emacs-style
  # backup notation -- they will have a ".~1~", ".~2~", etc. inserted before
  # the file extension at the end of $CFG::STEMCELL_TARBALL
  # (e.g. stemcell-x86_64-5-kvm.tgz.~1~).

  my $path = "$CFG::ARCHIVE_DIR/$CFG::STEMCELL_TARBALL";
  # No point in doing anything if $path doesn't exist already.
  return unless(-e $path);
  # There's already a $path.  Move it aside safely.
  my %dir;
  tie %dir, 'IO::Dir', $CFG::ARCHIVE_DIR, DIR_UNLINK;
  # Of course if there are already backup tarballs, move them aside too.
  # Collect the numbers of any files that fit the pattern.  Not assuming that
  # they're sequential.
  my @existing = sort {
    $a <=> $b
  } map {
    /\.~(\d+)~$/
  } grep {
    /^\Q$CFG::STEMCELL_TARBALL\E\.~\d+~$/
  } keys(%dir);
  # We want to retain only the most recent ($CFG::NBAK - 1) of them.  Delete
  # any older than that.
  if($#existing >= ($CFG::NBAK - 1)) {	# We'll be deleting some
    my @toohigh = @existing[($CFG::NBAK - 1)..$#existing];
    foreach my $i (@toohigh) {
      if($CFG::TEST_MODE) {
	printf("(test mode) delete %s.~%d~\n", $CFG::STEMCELL_TARBALL, $i);
      } else {
	delete $dir{sprintf('%s.~%d~', $CFG::STEMCELL_TARBALL, $i)};
      }
    }
    $#existing = $CFG::NBAK - 2;
  }
  # To prevent clobbering, rename them to a temporary scheme.
  my $j = 2;
  my @new = ();
  foreach my $i (@existing) {
    push(@new, $j);
    if($CFG::TEST_MODE) {
      printf("(test mode) rename %s.~%d~ -> %s.tmp.~%d~\n", $path, $i, $path, $j++);
    } else {
      rename(sprintf("%s.~%d~", $path, $i),
	     sprintf("%s.tmp.~%d~", $path, $j++));
    }
  }
  # Now rename them to a sequence of 2, ..., $CFG::NBAK
  $j = 2;
  foreach my $i (@new) {
    if($CFG::TEST_MODE) {
      printf("(test mode) rename %s.tmp.~%d~ -> %s.~%d~\n", $path, $i, $path, $j++);
    } else {
      rename(sprintf("%s.tmp.~%d~", $path, $i),
	     sprintf("%s.~%d~", $path, $j++));
    }
  }
  # Finally, rename the one without a backup extension to .~1~.
  if($CFG::TEST_MODE) {
    print("(test mode) rename $path -> $path.~1~\n");
  } else {
    rename($path, "$path.~1~");
  }
}

sub do_rebuild_stemcell {
  # Create a VM, boot it using PXE, and allow Cobbler to generate a stemcell
  # VM.  Then archive that VM for later copying with mkvm.

  unless($ENV{USER} eq 'root') {
    die("Must be root.\n");
  }

  if($CFG::KVM) {
    unless(&have_x11()) {
      die("Creating VMs requires X11.  Be sure it is enabled.\n");
    }
  }

  # For any routines we call that refer to this global
  $CFG::VM_NAME = $CFG::STEMCELL;

  # Make sure a VM with that name doesn't already exist
  if(&vm_name_exists($CFG::VM_NAME, '')) {
    die("Unable to proceed.\n");
  }

  # Canned settings for stemcell -- these are customized later, when mkvm
  # copies stemcell
  $CFG::USR_LOCAL_SIZE = &lvm_to_da('1G');
  $CFG::MEM_SIZE = &lvm_to_da('1G');
  $CFG::NUMVCPUS = 1;

  # Make sure we have enough space
  unless(&have_enough_space()) {
    die("Unable to proceed.\n");
  }

  # If you can think of any more reasons why we shouldn't go ahead and make the
  # VM, put them before this point

  # Prepare a place for the VM
  &prepare_vm_home();

  if($CFG::KVM) {
    # Make the disks
    my $hda_size = 32;
    my $hdb_size = &da_to_gib($CFG::USR_LOCAL_SIZE);
    my $ram_mb = &da_to_mib($CFG::MEM_SIZE);
    &create_vdisk_img("$CFG::VM_DIR/$CFG::STEMCELL-hda.qcow2", "${hda_size}G");
    &create_vdisk_img("$CFG::VM_DIR/$CFG::STEMCELL-hdb.qcow2", "${hdb_size}G");

    # Show the drives to libvirt.
    &test_cmd("virsh pool-refresh default");

    # In this case, where we're creating a stemcell VM, we want to make sure
    # that the eth1 network interface has a standardized MAC address that the
    # Cobbler server's system record can recognize.  Then it will know to boot
    # this VM into Anaconda and run the stemcell kickstart file.  The eth0 MAC
    # address is immaterial at this point, and we will have to remember to
    # change the MAC addresses to something unique when actually installing the
    # image.

    my $gmac = sprintf('52:54:00:04:00:%02X', $CFG::RHEL_V - 5);
    my $lmac = sprintf('52:54:00:06:00:%02X', $CFG::RHEL_V - 5);

    # Create the VM.
    # --pxe: boot from PXE the first time even though it has hard drives
    # --os-type, --os-variant: optimize hardware settings for type of OS
    # --check-cpu: warn if the number of virtual CPUs exceeds the number of physical CPUs
    # -k: set the type of keyboard for the VNC console
    # -n: set the name ("domain") of the VM
    # -r: set the amount of RAM in MB
    # --disk: add and configure a drive
    # --network: add and configure a network adapter
    # --autostart: the VM should start when the host boots up
    # --noreboot: the VM shouldn't reboot when installation is complete (this doesn't work anyway)
    # --wait: how long (in minutes) to wait for installation to finish (negative=forever)

    my $cmd = <<"EOF"
virt-install --pxe
  --os-type=linux --os-variant=rhel5.4
  --check-cpu -k en-us -n $CFG::STEMCELL -r $ram_mb --vcpus=$CFG::NUMVCPUS
  --disk path="$CFG::VM_DIR/$CFG::STEMCELL-hda.qcow2",bus=ide,format=qcow2,cache=none
  --disk path="$CFG::VM_DIR/$CFG::STEMCELL-hdb.qcow2",bus=ide,format=qcow2,cache=none
  --network bridge=br0,model=e1000,mac=$gmac
  --network bridge=br1,model=e1000,mac=$lmac
  --autostart --noreboot --wait=-1
EOF
      ;
    &test_cmd($cmd);

    # By default the VM should automatically reboot after installation (in
    # theory, at least; in practice it usually doesn't work), but we don't want
    # this, because we want to archive the disk image, not start it up.  To
    # this end, the PXE boot's kickstart should be configured to shutdown after
    # installation.  The virt-install command's --noreboot option should also
    # prevent it from rebooting after installation, and giving it a negative
    # value for its --wait time should make it wait indefinitely for the VM to
    # shut down after installation before continuing with this script.
    # Therefore, when we reach this point, the OS has been installed on the VM
    # and it has been shut down gracefully.  At this point we can copy the VM
    # to the server.

    print("Copying VM files to server ...\n");
    &test_cmd("virsh dumpxml $CFG::STEMCELL > /tmp/$CFG::STEMCELL.xml");
    &preserve_old_tarball();
    &test_cmd(<<"EOF");
tar zcSvf $CFG::ARCHIVE_DIR/$CFG::STEMCELL_TARBALL
  -C /
  /tmp/$CFG::STEMCELL.xml
  $CFG::VM_DIR/$CFG::STEMCELL-hda.qcow2
EOF
    ;
    &test_cmd("rm -f /tmp/$CFG::STEMCELL.xml");
    &do_rmvm($CFG::STEMCELL);
  } else {
    # Create a new VMware VM

    # Note that VMware MAC addresses should be 00:50:56:XX:YY:ZZ,
    # where XX is from 0x00 to 0x3f,
    # and YY and ZZ are from 0x00 to 0xff.

    my $gmac = sprintf('00:50:56:04:00:%02X', $CFG::RHEL_V - 5);
    my $lmac = sprintf('00:50:56:06:00:%02X', $CFG::RHEL_V - 5);

    my @vmxtext = map {
      chomp($_);
      if(/\w\s*=\s*"/) {
	my($key, $value) = (/^\s*(\S+)\s*=\s*\"?([^\"]*)\"?\s*$/);
	my %hash = (key => $key, value => $value);
	\%hash;
      } else {
	$_;
      }
    } split(/\n/, <<"EOF");
#!/usr/bin/vmware
config.version = "8"
virtualHW.version = "4"
logging = "FALSE"
autostop = "softpoweroff"
memsize = "1024"
displayName = "$CFG::STEMCELL"
guestOS = "other26xlinux-64"
priority.grabbed = "normal"
priority.ungrabbed = "normal"
powerType.powerOff = "hard"
powerType.powerOn = "hard"
powerType.suspend = "hard"
powerType.reset = "hard"

Ethernet0.present = "TRUE"
Ethernet0.virtualDev = "e1000"
Ethernet0.connectionType = "custom"
Ethernet0.vnet = "/dev/vmnet0"
ethernet0.addressType = "static"
ethernet0.address = "$gmac"

Ethernet1.present = "TRUE"
Ethernet1.connectionType = "custom"
Ethernet1.vnet = "/dev/vmnet2"
Ethernet1.virtualDev = "e1000"
ethernet1.addressType = "static"
ethernet1.address = "$lmac"

uuid.location = "00 11 22 33 44 55 66 77-88 99 aa bb cc dd ee ff"
uuid.bios = "00 11 22 33 44 55 66 77-88 99 aa bb cc dd ee ff"
uuid.action = "create"

floppy0.startConnected = "FALSE"
floppy0.fileName = "/dev/fd0"
floppy0.present = "FALSE"

ide0:0.present = "TRUE"
ide0:0.fileName = "hda.vmdk"
ide0:0.redo = ""

ide0:1.present = "TRUE"
ide0:1.fileName = "hdb.vmdk"
ide0:1.redo = ""

ide1:0.present = "FALSE"
ide1:0.fileName = ""
ide1:0.deviceType = "cdrom-image"
ide1:0.autodetect = "TRUE"
ide1:0.startConnected = "FALSE"

ide1:1.present = "FALSE"
ide1:1.fileName = ""
ide1:1.redo = ""

tools.syncTime = "FALSE"

checkpoint.vmState = ""

sched.mem.pshare.enable = "FALSE"
mainMem.useNamedFile = "FALSE"
MemTrimRate = "0"
MemAllowAutoScaleDown = "FALSE"

machine.id = "replace-with-vm-hostname"
autostart = "none"

guestinfo.autonet = ""
guestinfo.autoinstall = ""
guestinfo.shorthostname = "stemcell"
guestinfo.vmname = "stemcell"
guestinfo.rebuildstemcell = "1"
EOF
;

    # Write this to the .vmx file
    my $vmxfile = "$CFG::VM_DIR/$CFG::STEMCELL/$CFG::STEMCELL.vmx";
    unless($CFG::TEST_MODE) {
      my $fh = IO::File->new();
      $fh->open(">$vmxfile") || die("Unable to open $vmxfile: $!\n");
      foreach my $line (@vmxtext) {
	if(ref($line)) {
	  $fh->printf("%s = \"%s\"\n", $line->{key}, $line->{value});
	} else {
	  $fh->printf("%s\n", $line);
	}
      }
      $fh->close();
    }

    # Make the virtual disk images

    # vmware-vdiskmanager [<options>] <filename>
    # Options:
    # -c: create a virtual disk
    # -a ide: make an IDE disk rather than SCSI
    # -s $sectors: specify size of disk; sectors is the most precise unit
    #   allowed by VMware
    # -t 2: type of disk (0=monolithic growable, 1=split growable,
    #   2=monolithic preallocated, 3=split preallocated)
    # <filename>: name of disk file (for monolithic types) or name of main file
    #   (for split types)

    # Make the main virtual disk
    my $sectors = &da_to_sectors('32gib');
    &test_cmd(<<"EOF");
vmware-vdiskmanager -c
  -a ide
  -s $sectors
  -t 0
  $CFG::VM_DIR/$CFG::STEMCELL/hda.vmdk
EOF
    ;

    # Make the new /usr/local virtual disk
    $sectors = &da_to_sectors($CFG::USR_LOCAL_SIZE);
    &test_cmd(<<"EOF");
vmware-vdiskmanager -c
  -a ide
  -s $sectors
  -t 0
  $CFG::VM_DIR/$CFG::STEMCELL/hdb.vmdk
EOF
    ;

    # Get the nvram file if it exists
    if(-e "$CFG::ARCHIVE_DIR/nvram.vmw") {
      &test_cmd("install -oroot -gvm -m0660 $CFG::ARCHIVE_DIR/nvram.vmw $CFG::VM_DIR/$CFG::STEMCELL/nvram");
    }

    # Make sure we have modes and permissions set correctly
    &set_owners_perms("$CFG::VM_DIR/$CFG::STEMCELL");

    # Register the VM.
    &test_cmd("vmware-cmd -s register $vmxfile");

    # Boot the VM so it will run Anaconda via PXE.
    &do_start($CFG::STEMCELL);

    # Wait for it to be down again.
    print(<<"EOF");
Waiting while stemcell installs the OS on itself.

Note that due to a bug in VMware Server that will certainly never be fixed
because VMware Server was end-of-lifed in mid-2011, there is likely to be a
long pause during the initial kernel boot decompression stage.  This pause can
be as long as 7 minutes.

This bug is not present in KVM virtual machines.
EOF
    ;
    unless($CFG::TEST_MODE) {
      while(&vm_running($CFG::STEMCELL)) {
	sleep(5);
      }
    }

    # At this point we can copy the VM to the server.
    print("Copying VM files to server ...\n");
    &preserve_old_tarball();
    my $tarok = &test_cmd(<<"EOF");
tar zcSvf $CFG::ARCHIVE_DIR/$CFG::STEMCELL_TARBALL
  -C /$CFG::VM_DIR
  --exclude $CFG::STEMCELL/hdb.vmdk
  --exclude $CFG::STEMCELL/*.pl
  --exclude $CFG::STEMCELL/*.bak
  --exclude $CFG::STEMCELL/*.log
  --exclude $CFG::STEMCELL/lost+found
  $CFG::STEMCELL
EOF
    ;

    # Now that we've copied it, we don't need it anymore.
    &do_rmvm($CFG::STEMCELL) if($tarok == 0);
  }
}

sub do_rmvm {
  # Remove a VM.
  # Make sure we have a VM name

  # Root check
  if($ENV{USER} ne 'root') {
    die("Must be root.\n");
  }
  # If we are given a VM name in the routine's parameters, use that.  That lets
  # us delete VMs from other routines.
  my($vm_name) = @_;
  # Otherwise, use the first command-line parameter as the VM name.
  $vm_name ||= $ARGV[0];
  # Set this global for routines that refer to it.
  $CFG::VM_NAME = $vm_name;
  # Test the proposed name.
  unless(&vm_name_exists($vm_name, 1)) {
    warn("Unable to proceed.\n");
    if($vm_name eq '') {
      &main::HELP_MESSAGE();
    }
    exit 1;
  }
  # VM running?
  if(&vm_running($vm_name)) {
    die("VM is running; unable to proceed\n");
  }
  if($CFG::KVM) {
    # Parse the XML using XML::Twig to get the virtual disk files
    my @vol = ();
    my $xml = join(' ', `virsh dumpxml $vm_name`);
    my $t = XML::Twig->new();
    $t->parse($xml);
    my @elts = $t->get_xpath('//disk/source[@file]');
    foreach my $elt (@elts) {
      push(@vol, $elt->{att}->{file});
    }
    # Undefine the domain
    print("Undefining $vm_name ...\n");
    &test_cmd("virsh undefine $vm_name");
    # Remove the volumes
    foreach my $vol (@vol) {
      printf("Deleting %s ...\n", $vol);
      &test_cmd("rm -f $vol");
    }
    # Refresh the pool so virsh knows they're gone
    &test_cmd("virsh pool-refresh default");
  } else {
    # Tell VMware to drop this VM.
    &unregister_vm($vm_name);
    if($CFG::VM_HOST_TYPE eq 'vmw') {
      # Unmount the volume.
      &test_cmd("umount $CFG::VM_DIR/$vm_name");
    }
    # Remove the subdirectory or mount point.
    &test_cmd("rm -rf $CFG::VM_DIR/$vm_name");
    # Remove the mount line from /etc/fstab.
    if($CFG::VM_HOST_TYPE eq 'vmw') {
      &test_cmd("cp --preserve=all /etc/fstab /etc/fstab.bak");
      &test_cmd("grep -Ev ^[^[:space:]]+[[:space:]]+$CFG::VM_DIR/$vm_name/?[[:space:]] /etc/fstab.bak > /etc/fstab");
      # Get rid of the LV, first waiting a few seconds to make sure things
      # settle down (rmvm has crashed LVM in the past; it's good to be careful
      # here).
      sleep(3);
      # Switch the LV to non-active.  This may also help to prevent LVM
      # trouble.
      &test_cmd("lvchange -a n /dev/$CFG::VM_VG/$vm_name");
      sleep(3);
      &test_cmd("lvremove /dev/$CFG::VM_VG/$vm_name");
    }
  }
  print("VM deleted.\n");
}

sub do_mvvm {
  # Do the mvvm command, renaming a VM.  The old and new VM names must be the
  # arguments.

  # Check for rootness
  if($ENV{USER} ne 'root') {
    die("Must be root.\n");
  }
  # Get the old and new VM names.
  my($vm_old_name, $vm_new_name) = @ARGV;
  # Make sure the old VM exists
  unless(&vm_name_exists($vm_old_name)) {
    warn("Unable to proceed.\n");
    if($vm_old_name eq '') {
      &main::HELP_MESSAGE();
    }
    exit 1;
  }
  # Test the proposed new name.
  unless(&vm_name_ok($vm_new_name)) {
    warn("Unable to proceed.\n");
    if($vm_new_name eq '') {
      &main::HELP_MESSAGE();
    }
    exit 1;
  }
  # Eventually we'll get this working for KVM, but it hasn't been in high
  # demand.  It's rarely used even on VMware.
  if($CFG::KVM) {
    die("mvvm not yet implemented for KVM hosts\n");
  }
  # Can't rename a running VM
  if(&vm_running($vm_old_name)) {
    die("The VM '$vm_old_name' is currently running; cannot rename\n");
  }
  # If you can think of any more reasons why we shouldn't go ahead and rename
  # the VM, put them before this point

  # Tell VMware to forget about this VM under its old name.
  &unregister_vm($vm_old_name);
  chdir($CFG::VM_DIR);
  if($CFG::VM_HOST_TYPE eq 'vmw') {
    # Unmount the VM under its old name
    &test_cmd("umount $vm_old_name");
    # Generate the new filesystem label
    my $vm_ext2_label = &make_ext2_label($vm_new_name);
    # Change the filesystem label
    &test_cmd("e2label /dev/$CFG::VM_VG/$vm_old_name $vm_ext2_label");
    # Change the line in /etc/fstab -- replace line with sed
    &test_cmd("sed -i.bak -re '!^[^[:space:]]+[[:space:]]+$CFG::VM_DIR/$vm_old_name/?[[:space:]]!cLABEL=$vm_ext2_label	$CFG::VM_DIR/$vm_new_name	ext3	defaults	1 2' /etc/fstab");
    # Deactivate the LV
    &test_cmd("lvchange -a n /dev/$CFG::VM_VG/$vm_old_name");
    # Rename the LV
    &test_cmd("lvrename $CFG::VM_VG $vm_old_name $vm_new_name");
    # Reactivate the LV
    &test_cmd("lvchange -a y /dev/$CFG::VM_VG/$vm_new_name");
  }
  # Change the mount point or directory's name
  &test_cmd("mv $vm_old_name $vm_new_name");
  if($CFG::VM_HOST_TYPE eq 'vmw') {
    # Remount the LV
    &test_cmd("mount $vm_new_name");
  }
  chdir("$CFG::VM_DIR/$vm_new_name");
  # Change the .vmx file's name
  &test_cmd("mv $vm_old_name.vmx $vm_new_name.vmx");
  # Change the displayname within the .vmx file
  &test_cmd("sed -i.bak -re '/^[[:space:]]*displayname[[:space:]]*=[[:space:]]*\"/IcdisplayName = \"$vm_new_name\"' $vm_new_name.vmx");
  # Tell VMware to open the VM under its new name
  &register_vm($vm_new_name);
  # Set the owner/group/permissions of the files, just to make sure
  &set_owners_perms("$CFG::VM_DIR/$vm_new_name");
}

sub do_allvm {
  # Basically this just runs the vmware-cmd or virsh command on all vms on the
  # system, which is something I found myself doing a lot by hand

  # Ensure rootitude
  if($ENV{USER} ne 'root') {
    die("Must be root.\n");
  }
  # Make sure there's a command
  my $cmd = shift(@ARGV);
  unless($cmd) {
    &main::HELP_MESSAGE();
    exit 1;
  }
  # Get args
  my @args = @ARGV;
  # Execute command based on VM host type
  if($CFG::KVM) {
    foreach my $line (`virsh list --all`) {
      $line =~ s/^\s+//;
      next if($line =~ /^id\s+name/i);
      next if($line =~ /^---/);
      next if($line =~ /^\s*$/);
      my($id, $vm) = split(/\s+/, $line);
      printf("%s ", $vm);
      &test_cmd(sprintf("virsh %s %s", join(' ', $cmd, @args), $vm));
    }
  } else {
    foreach my $vm (`vmware-cmd -l`) {
      printf("%s ", $vm);
      &test_cmd(sprintf("vmware-cmd %s %s", $vm, join(' ', $cmd, @args)));
    }
  }
}

sub do_rebuild_vmware {
  # I find myself doing this all the time too, on VMware hosts anyway --
  # whenever the kernel is updated, VMware Server won't start, because its
  # kernel modules need to be rebuilt.  But of course the vmware-config.pl
  # script that VMware provides also clobbers the contents of
  # /etc/vmware/config and /etc/pam.d/vmware-authd, which we've carefully tuned
  # for our purposes.  So this command preserves those files, runs
  # vmware-config.pl, and restarts VMware Server, all in one command, reducing
  # a laborious process that used to take 5 minutes or more (the more user
  # interaction required, the more pauses there are in the process) to
  # something that takes under 1 minute and only one command.

  # No need for this on KVM
  if($CFG::KVM) {
    die("You don't need to rebuild VMWare Server -- this is a KVM host!\n");
  }
  # Non-root verboten
  if($ENV{USER} ne 'root') {
    die("Must be root.\n");
  }
  # Since vmware won't run unless this is done, if it's running now, it must
  # already have been done, so don't do it again.
  if((system("service vmware status") >> 8) == 0) {
    die("Not reconfiguring vmware server -- it doesn't need it, as it's currently running.\n");
  }
  my $config = '/etc/vmware/config';
  my $authd = '/etc/pam.d/vmware-authd';
  warn("Reconfiguring vmware server ...\n");
  foreach my $file ($config, $authd) {
    &test_cmd("cp -fp $file $file.bak");
  }
  &test_cmd("/usr/bin/vmware-config.pl -c -d -skipstopstart");
  foreach my $file ($config, $authd) {
    &test_cmd("cp -fp $file.bak $file");
  }
  # Run this fix before starting it back up
  &fix_vmware_perl_api_errors();
  &test_cmd("service vmware start");
}

sub do_stop {
  # Shut down a VM in the proper way, and wait for it to be stopped

  my($vm_name) = @_;
  $vm_name ||= $ARGV[0];
  unless(&vm_running($vm_name)) {
    die("VM not running -- unable to proceed\n");
  }
  if($CFG::KVM) {
    &test_cmd("virsh shutdown $vm_name");
  } else {
    my $vmxfile = "$CFG::VM_DIR/$vm_name/$vm_name.vmx";
    &test_cmd("vmware-cmd $vmxfile stop");
  }
  unless($CFG::TEST_MODE) {
    # Wait for it to actually be down
    while(&vm_running($vm_name)) {
      sleep(5);
    }
  }
}

sub do_start {
    # Start up a VM, and wait until it is started

  my($vm_name) = @_;
  $vm_name ||= $ARGV[0];
  if(&vm_running($vm_name)) {
    die("VM already running -- unable to proceed\n");
  }
  if($CFG::KVM) {
    # Do a "virsh start" on it
    &test_cmd("virsh start $vm_name");
  } else {
    my $vmxfile = "$CFG::VM_DIR/$vm_name/$vm_name.vmx";
    &test_cmd("vmware-cmd $vmxfile start");
  }
  unless($CFG::TEST_MODE) {
    # Wait for it to actually be up
    until(&vm_running($vm_name)) {
      sleep(5);
    }
  }
}

sub do_snapshot_all {
    # Another common function I find myself doing all the time.  For each VM
    # that's up, we're going to stop it, delete its disk image backups or merge
    # its snapshot, make new backups or a new snapshot, and then restart it.

  foreach my $vm_name (`lsvm | grep 'up\$' | cut -d ' ' -f 1`) {
    printf("%s: stop\n", $vm_name);
    &do_stop($vm_name);
    if($CFG::KVM) {
      # Delete its disk image backups and make new backups
      chdir('/var/lib/libvirt/images');
      printf("%s: delete old backups\n", $vm_name);
      &test_cmd("rm -f $vm_name*.bak");
      printf("%s: make new backups\n", $vm_name);
      &test_cmd("for i in $vm_name*; do cp -p \$i \$i.bak; done");
    } else {
      # Merge its snapshot and make a new snapshot
      my $vmxfile = "$CFG::VM_DIR/$vm_name/$vm_name.vmx";
      printf("%s: merge snapshot\n", $vm_name);
      &test_cmd("vmrun deleteSnapshot $vmxfile");
      printf("%s: snapshot\n", $vm_name);
      &test_cmd("vmrun snapshot $vmxfile");
    }
    # Restart it
    printf("%s: start\n", $vm_name);
    &do_start($vm_name);
  }
}

###############################################################################
# Main script
###############################################################################

# Do initialization stuff.
&init();

###############################################################################
# lsvm -- list all VMs
###############################################################################

if($CFG::CALLED_AS eq 'lsvm') {
  &do_lsvm();
}

###############################################################################
# mkvm -- make a VM
###############################################################################

elsif($CFG::CALLED_AS eq 'mkvm') {
  &do_mkvm();
}

###############################################################################
# mkvm_classic -- make a VM the "classic" way
###############################################################################

elsif($CFG::CALLED_AS eq 'mkvm_classic') {
  &do_mkvm_classic();
}

###############################################################################
# rebuild_stemcell -- makes a VM, boots from PXE, and creates a stemcell
###############################################################################

elsif($CFG::CALLED_AS eq 'rebuild_stemcell') {
  &do_rebuild_stemcell();
}

###############################################################################
# rmvm -- delete a VM
###############################################################################

elsif($CFG::CALLED_AS eq 'rmvm') {
  &do_rmvm();
}

###############################################################################
# mvvm -- change a VM's name
###############################################################################

elsif($CFG::CALLED_AS eq 'mvvm') {
  &do_mvvm();
}

###############################################################################
# allvm -- run a vmware-cmd or virsh command on all VMs
###############################################################################

elsif($CFG::CALLED_AS eq 'allvm') {
  &do_allvm();
}

###############################################################################
# rebuild_vmware -- smart wrapper for vmware-config.pl
###############################################################################

elsif($CFG::CALLED_AS eq 'rebuild_vmware') {
  &do_rebuild_vmware();
}

###############################################################################
# vmup -- bring a VM up
###############################################################################

elsif($CFG::CALLED_AS eq 'vmup') {
  &do_start();
}

###############################################################################
# vmdown -- bring a VM down
###############################################################################

elsif($CFG::CALLED_AS eq 'vmdown') {
  &do_stop();
}

###############################################################################
# snapshot_all -- merge snapshots/delete backups and then re-snapshot
###############################################################################

elsif($CFG::CALLED_AS eq 'snapshot_all') {
  &do_snapshot_all();
}

###############################################################################
# Unknown command -- this would be if someone ran vmtool itself sans symlink
###############################################################################

else {
  warn("Please call this script as lsvm, mkvm, mvvm, etc.\n");
}
